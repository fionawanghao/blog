#常见的排序方法的时间复杂度

时间复杂度原则上是算不出来的，只有上机测试才可以，但是可以相对的比较出不同算法中哪一种消耗的时间更多。时间复杂度是指执行次数随着问题规模n增加的增长趋势，用函数O（）表示，时间复杂度越高，程序效率越低。

###冒泡排序

####代码清单

```
      function bubbleSort($arr){
                for($i=0;$i<count($arr);$i++){
                        for($j=0;$j < count($arr)-$i-1;$j++){
                                if($arr[$j] > $arr[$j+1]){
                                        $tmp = $arr[$j+1];
                                        $arr[$j+1] = $arr[$j];
                                        $arr[$j] = $tmp;
                                }
                        }
                }
                return $arr;
        }

```
原理：从第一个数字开始依次与后面的数字比较，更小的数字数字会像冒泡一样漂到上面（前面）去
####时间复杂度分析

冒泡排序执行了两层循环，外面的循环执行了n次，里面的循环执行了n次（这里n代表的是问题的规模，本来时间复杂度还是一个估算所以这里不必纠结i和j不相等的问题），因此冒泡排序的时间复杂度的就是O(n^2)，至于空间复杂度因为无论循环多少次只是借用了一个临时变量所以耗费的多余空间都是储存这个临时变量的空间，因此空间复杂度是S(1)(不随问题规模n的增加而变化)。关于冒泡排序进行一些改进，当给出的数组是排好序的时候，其时间会降低为O（n),改进后的代码如下：
```
        function BubbleSort($data) {
            for($i = 0; $i < count($data); $i++) {
		$didSwap = false;
                for ($j=0; $j< count($data) - $i - 1; $j++) {
                    if($data[$j] > $data[$j+1]) {
                        $temp = $data[$j];
                        $data[$j] = $data[$j+1];
                        $data[$j+1] = $temp ;
			 $didSwap = true;
                    }	
		}
		if ($didSwap == false) {
			break;
		}
            }
            return $data;
        }
```
如上面的代码所示，如果给出的数据正好是已经按照要求排好序的，那么内层的循环中if条件就不会成立，那么$didSwap的值就不会变成true，这样的话当外层的第一次循环完成之后就直接break出来了，这样的话无论有多少个数据外层循环就只执行了一次。这样的话时间复杂度就只跟内层的循环次数有关，也就是O(n)。

###快速排序

####代码清单

```
        function quickSort($arr){
                if(is_array($arr)){
                        $tmp = $arr[0];
                }
                $len = count($arr);
                $right = array();
                $left = array();
                for($i = 1; $i < $len; $i++){
                        if($arr[$i] > $tmp){
                                $right[] = $arr[$i];
                        }else{
                                $left[] = $arr[$i];
                        }
                }

                if (!empty($left)) {
                        $left = quickSort($left);
                }
                if (!empty($right)) {
                        $right = quickSort($right);
                }
                return array_merge($left,array($tmp),$right);
        }
```
原理：选择一个默认的中间值（默认第一个值），后面所有的数据与该值比较，比它小的放在左边数组大的放在右边数组，然后递归，直到左右数组中只有至多两个值，再把左边数组中间值右边数组连接起来
####时间复杂度分析

快速排序的话，涉及到递归，每个递归里面又有循环，那么时间复杂度就是递归的次数乘以每次递归循环的次数(n)。关于递归次数的计算，可以这样推断，如果是八个数据的话，需要递归三次才可以得到两个可以比较的数据比较的数字也就是log8，于是我们推断出，如果有n个数据的话我们需要递归logn次。因此快速排序的时间复杂度是O(nlogn)。每次循环的时候需要将分出来的数据进行保存，有多少个保存多少也就是占用了n个额外的空间，这是每次递归的空间复杂度还要乘以递归的次数所以最终得出快排序的空间复杂度是S(nlogn)。快速排序有一个最糟糕的情况就是拿到的数据是倒序或者正序排好的。这样的话，每一次以第一个数据为中间数据分割的时候都是左边或者右边的数组为空，二分的做法完全不起作用，时间复杂度顿时增加为O(n^2)。

###插入排序

####代码清单

```
        function insertSort($arr){
                for($i=1;$i<count($arr);$i++){
                        $tmp = $arr[$i];
                        for($j=$i-1;$j>=0;$j--){
                                if($tmp  < $arr[$j]){
                                        $arr[$j+1] = $arr[$j];
                                        $arr[$j] = $tmp;
                                }else{
                                        break;
                                }
                        }
                }
                return $arr;
        }
       
```
####原理：

从第二个数字（作为第一个要插入的数字）开始，依次与前面的数字比较，遇到比要插入的数字大的就插入到它的前面，否则退出里面的循环，外层的循环继续要插入的数字变为第三个，依此类推。
####时间复杂度分析

插入排序的时间复杂度是O(n^2)，空间复杂度是S(1)，计算方法与冒泡排序相似不再分析请参考冒泡排序。最好的情况也是拿到的数据是按照要求已经排好的。如果已经排好的话，里层的循环执行第一次的时候就会直接break出来，也就是说里层循环的执行次数不随着问题规模的增加而增加，所以最好的情况下插入排序的时间复杂度是S(n),也就是外层循环的执行次数。

###选择排序

####代码清单

```
        function selectSort($arr){
                for($i=0;$i<count($arr)-1;$i++){
                        $p = $i;
                        for($j=$i+1;$j<count($arr)-i-1;$j++){
                                if($arr[$j] < $arr[$p]){
                                        $p = $j;
                                }
                                if($p != $i){
                                        $tmp = $arr[$i];
                                        $arr[$i] = $arr[$p];
                                        $arr[$p] = $tmp;
                                }
                        }
                }
                return $arr;
        }
```
#####原理：

选择排序就是依次把数据的认为是最小的那个把它的下标赋给变量p，如果后面发现有更小的数字，那么就把该元素的下标作为最小的数字的下标赋值给变量p，然后判断最小数字下标P是否发生变化，如果发生变化就把当前选择的最小数字和下标为p的数字交换。
####时间复杂度分析

选择排序也是两层循环在时间复杂度方面跟冒泡排序和插入排序一样,而且用到的额外存储空间也不会随着数据的增多而增多，所以时间复杂度是O(n^2)，空间复杂度是S(1)。跟前面提到的两中排序不同的是，没有办法判断出是否是排好的也就是没有break的条件，所以没有最好的情况。

###下面是这几种排序方法时间复杂度和空间复杂度的总结：

| 排序方法|     平均时间复杂度|    最好时间复杂度|      最坏时间复杂度|    空间复杂度   |      稳定性
|--------:| ----:|----|---|----|----------------
|冒泡排序 |    O(n^2)            | O（n）         |    O(n^2)      |    O(1)       |     稳定
|快速排序    | O(nlogn)    |      O(nlogn)       |   O(n^2)    |       O(nlogn)       |不稳定
|插入排序     | O(n^2)          |  O(n)       |       O(n^2)  |         O(1)        |    稳定
|选择排序    | O(n^2)          |  O(n^2)        |    O(n^2)          | O(1)  |         不稳定




注意：以上的代码示例和分析都是基于正序排序。